## 트레잇

추상화를 사용하게 해줌

타입들이 공통적으로 갖는 동작에 대해 추상화

어떠한 목적을 달성하기 위해 필요한 동작의 집합을 정의하기 위해 메소드 시그니처들을 함께 묶는 것


## 트레잇 바운드

이게 이해가 잘 안감

제너릭 타입을 사용하는 트레잇이라하는데

제너릭 타입이 특정한 트레잇을 구현하여

이 타입들이 가지고 있을 필요가 있는 동작을 갖고 있도록 

타입들로 제한함을 컴파일러가 확신하도록 함

이라는데 먼소리여..

```
pub fn notify<T: Summarizable>(item: T) {
    println!("{}", item.summary());
}
```

T에 Summarizable 트레잇을 impl 한걸 가지고 올 수 있는것 같음

+를 하면 하나의 제너릭 타입에 대해 여러개의 트레잇 바운드를 특정할 수 있다고 함.

where를 사용해서 이쁘게 사용 가능

```
fn foo<T, U>(t: T, u: U) -> i32 
    where T: Display + Clone,
          U: Clone + Debug {



    }

```

ㅇㅋ 이해했음



# 라이프타임

라이프타임은 댕글링 참조자를 방지함

```
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

여기서는 x가 없어져있는데  r이 x를 참조함


Borrow Checker를 통해서 모든 빌림이 유효한지를 결정함.


## 라이프타임 명시 문법

어퍼스트로피 ' 이걸로 시작해야함
&i32    //그냥 레퍼
&'a i32 // 명시된 라이프타임을 가진 레퍼런스

```
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

```

라이프타임 문법은 함수들의 다양한 인자들과 반환 값 사이를 연결하는 것

